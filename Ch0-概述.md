# 什么是Code-Prompt

简单来说, 像写代码一样来构建你的提示词

# 鸣谢

## 结构化提示词

> 我的工作是在他们的基础上做了一些小小的总结, 希望能对您产生一些帮助

[结构化提示词](https://langgptai.feishu.cn/wiki/RXdbwRyASiShtDky381ciwFEnpe)

## 李继刚-Lisp Prompt

[汉语新解](https://m.okjike.com/originalPosts/66e263c2610bbfc39f1a4031)

# 为什么要Code-Prompt?

1. 可执行性：Code-prompt不仅是一种描述，它实际上是可以运行的代码。这意味着我们可以直接测试和验证Prompt的行为，而不仅仅是猜测它会如何工作。

2. 模块化：代码结构允许我们将复杂的Prompt拆分成多个函数或模块。这使得我们可以更容易地管理和维护大型、复杂的Prompt。

3. 可重用性：函数式的结构使得Prompt的各个部分可以被轻松地重用或在不同场景中应用。

4. 版本控制：像管理代码一样管理Prompt，我们可以使用版本控制系统来跟踪Prompt的变化，进行协作开发，并在需要时回滚到之前的版本。

5. 清晰的逻辑流：代码结构使得Prompt的逻辑流程更加清晰。我们可以清楚地看到整个思考-行动-观察的循环过程。

6. 错误处理：我们可以像处理代码中的错误一样处理Prompt中可能出现的问题，提高系统的健壮性。

7. 类型安全：通过使用类型注解，我们可以明确定义输入和输出的类型，减少错误并提高代码的可读性。

8. 文档集成：我们可以使用代码注释和文档字符串来详细说明Prompt的各个部分，这些可以被自动化工具提取生成文档。

9. 工具链集成：代码形式的Prompt可以更好地集成到现有的开发工具链中，如IDE、linter、formatter等，从而提高开发效率。

# 编程语言选择

和传统的编程语言不同, Code-Prompt不追求所谓的工程健壮性, 代码鲁棒性等等

我们最关注的是以下几点:

- 代码的表达能力
- 包管理能力
- 接近自然语言的书写方式
- LLM熟悉且擅长

以下是我的主观意见评分, 其实我认为Java最合适的评分是0分.

我还记得之前在Leetcode上老是有一行代码解决XX问题, 大部分都是Python, 虽然总是有人说这不就是调包吗?

但是在Code-Prompt中, 我们是鼓励调包的, 详细的原因会在后续章节

| 编程语言    | 代码表达能力 | 包管理能力 | 接近自然语言 | LLM熟悉度 | 总体评分 |
|------------|------------|------------|-------------|----------|---------|
| Python     | 5/5        | 5/5        | 4/5         | 5/5      | 19/20   |
| JavaScript | 4/5        | 5/5        | 3/5         | 5/5      | 17/20   |
| TypeScript | 5/5        | 5/5        | 3/5         | 4/5      | 17/20   |
| Ruby       | 4/5        | 4/5        | 5/5         | 4/5      | 17/20   |
| Rust       | 5/5        | 5/5        | 2/5         | 3/5      | 15/20   |
| Golang     | 4/5        | 4/5        | 3/5         | 4/5      | 15/20   |
| Java       | 4/5        | 4/5        | 2/5         | 5/5      | 15/20   |
| C#         | 4/5        | 4/5        | 3/5         | 4/5      | 15/20   |
| C/C++      | 5/5        | 3/5        | 1/5         | 4/5      | 13/20   |
| Lisp       | 5/5        | 3/5        | 3/5         | 4/5      | 15/20   |
| Scala      | 5/5        | 4/5        | 3/5         | 3/5      | 15/20   |
| Julia      | 5/5        | 4/5        | 4/5         | 3/5      | 16/20   |
| Haskell    | 5/5        | 4/5        | 2/5         | 3/5      | 14/20   |

综上, 这个Repo使用的所有示例都是基于Python的

# 指令遵从

为了让LLM更好的"扮演"一段程序, 我们必须强化这个指令.

在尝试了一段时间之后, 我给出一个初版的指令, 目前看来遵循效果还可以:
```
# YOU ARE A PROCESS, EXECUTE THE FOLLOWING CODE!
# ONLY OUTPUT THE CODE RESULT!
```


同时在最后的函数执行前, 增加

`this is the only process you should do`

# 说明

如果没有额外说明, 那么所有的LLM示例都是基于deepseek-chat (世界上最好的LLM), 温度0.7